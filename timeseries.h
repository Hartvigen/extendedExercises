//============================================================================
// Name        : extended1/timeseries.h
// Author      : Simonas Saltenis
// Version     :
// Description : Extended exercise 1 of the sP course: Definitions of TimeSeries and TimeSeriesH classes
//============================================================================

#ifndef TIMESERIES_H_INCLUDED
#define TIMESERIES_H_INCLUDED

#include <vector>
#include <limits>
#include <memory>
#include <iostream>

namespace TimeData
{

class TimeSeries
{
public:
    TimeSeries() = default;
    TimeSeries(std::initializer_list<int> ts) : data{ts}    // constructor for testing
    { updateMinMax(); }

    // Note that I follow the rule of zero and do not define any copy/move constructors/assignemnt operators.
    // The default ones generated by the compiler (doing memberwise copy/move) are good enough.
    // This relies on correct and efficient copy/move operations of std::vector
    // In particular the move operations of std::vector do not copy all the data contained.

    using size_type = std::vector<int>::size_type;  // reusing the vectors's size type

    static TimeSeries makeRandom(size_type n);

    TimeSeries& addValue (int v);

    unsigned amplitude () const                             // small member functions inline
    { return static_cast<unsigned>(maxValue) - minValue; }  // avoiding signed integer overflow

    bool operator<(const TimeSeries& t) const
    { return amplitude() < t.amplitude(); }

    // Note const and reference/value return types for these two operators
    TimeSeries& operator+=(const TimeSeries& t);
    TimeSeries  operator+ (const TimeSeries& t) const
    { return TimeSeries(*this) += t; }   // This shows that both operators have the same semantics

    friend std::ostream& operator<< (std::ostream& out, const TimeSeries& ts);

private:
    void updateMinMax();          // should be invoked when data is modified

    std::vector<int> data;
    int              maxValue{std::numeric_limits<int>::min()};    // maximum value in data
    int              minValue{std::numeric_limits<int>::max()};    // minimum value in data
    // int              monthlyAverages[12];
};

// I choose to define short member functions inline
//----------------------------------------------------------
inline TimeSeries& TimeSeries::addValue (int v)
{
    data.push_back(v);
    if (v > maxValue) maxValue = v;
    if (v < minValue) minValue = v;

    return *this;
}

//----------------------------------------------------------
// A handle class wrapping a pointer to TimeSeries, but providing the same interface.
// The class would look basically the same if a naked pointer was used instead of unique_ptr,
// the only difference being the destructor that deletes the TimeSeries pointed by the pointer.
// Note how make_unique is consistently used avoiding naked calls to new.
// See Item 21 in Effective Modern C++
//
class TimeSeriesH
{
public:
    TimeSeriesH() :
        tsp{std::make_unique<TimeSeries>()} {}
    TimeSeriesH(std::initializer_list<int> ts) :
        tsp{std::make_unique<TimeSeries>(ts)} {}

    // We have to provide the copy constructor and the copy assignemnt operator, because
    // we want a deep copy (and unique_ptr can not be copied even if we wanted)
    // Note that these two constructors and the rest of the methods assume that tsp is not nullptr!
    // While we make sure that our constructors and everything else in the code never initializes/assigns nullptr
    // to tsp (and tsp is private, so it can not be changed from outside), we can not be sure that
    // the compiler generated default move constructor/assignment (which delegate to the corresponding move operations
    // of unique_ptr) do not set the moved-from unique_ptr to nullptr (and, e.g., move operations of the gcc version
    // of unique_ptr actually do set the moved-from object to nullptr). Thus, this class is not bullet-proof safe --
    // we can not work with moved-from objects (which is almost never done...).
    // If we nevertheless wanted to fix this, we could either:
    // 1) check for tsp == nullptr in all methods, or 2) provide our own move operations (that, for example, swap).
    //
    TimeSeriesH(const TimeSeriesH& tsh) : tsp{std::make_unique<TimeSeries>(*tsh.tsp)} {}

    TimeSeriesH& operator=(const TimeSeriesH& tsh)
    {
        *tsp = *tsh.tsp;     // delegate to TimeSeries::operator=
        return *this;
    }

    // For efficiency, we ask for the default versions of the move constructor/assignment operator.
    // They rely on the move constructor/operator= of unique_ptr. If we did not do that,
    // the copy constructor/operator= would be used everywhere , which is OK, but not efficient.
    // (try to see how the performance of sorting changes when the following two lines are commented out)
    //
    TimeSeriesH(TimeSeriesH&& tsh) noexcept = default;
    TimeSeriesH& operator=(TimeSeriesH&& tsh) noexcept = default;
    ~TimeSeriesH() = default;   // We document that there is a default destructor: rule of five!

    static TimeSeriesH makeRandom(TimeSeries::size_type n)
    { return TimeSeriesH(std::make_unique<TimeSeries>(TimeSeries::makeRandom(n))); }

    TimeSeriesH& addValue (int v)
    {
        tsp->addValue(v);
        return *this;
    }

    unsigned amplitude () const
    { return tsp->amplitude(); }

    bool operator<(const TimeSeriesH& t) const
    { return *tsp < *t.tsp; }

    TimeSeriesH& operator+=(const TimeSeriesH& t)
    {
        *tsp += *t.tsp;
        return *this;
    }

    TimeSeriesH operator+ (const TimeSeriesH& t) const
    { return TimeSeriesH(std::make_unique<TimeSeries>(*tsp + *t.tsp)); }

    friend std::ostream& operator<< (std::ostream& out, const TimeSeriesH& ts);

private:
    // A convenient constructor for makeRandom factory function and operator+
    // It is not made public to avoid problems, like creating TimeSeriesH with a null pointer.
    //
    TimeSeriesH (std::unique_ptr<TimeSeries>&& p) : tsp{std::move(p)} {}

    std::unique_ptr<TimeSeries> tsp;
};

inline std::ostream& operator<< (std::ostream& out, const TimeSeriesH& ts)
{
    return out << *ts.tsp;
}

}   // namespace TimeData

#endif // TIMESERIES_H_INCLUDED
