//============================================================================
// Name        : extended1/timeseries.h
// Author      : Simonas Saltenis
// Version     :
// Description : Extended exercise 1 of the sP course: Definitions of TimeSeries and TimeSeriesH classes
//============================================================================

#ifndef TIMESERIES_H_INCLUDED
#define TIMESERIES_H_INCLUDED

#include <vector>
#include <memory>
#include <iostream>
#include "measurements.h"

namespace TimeData
{

class TimeSeries
{
public:
    TimeSeries() = default;
    TimeSeries(TimeSeries && t) = default;// constructor for testing

    // Note that I follow the rule of zero and do not define any copy/move constructors/assignemnt operators.
    // The default ones generated by the compiler (doing memberwise copy/move) are good enough.
    // This relies on correct and efficient copy/move operations of std::vector
    // In particular the move operations of std::vector do not copy all the data contained.

    using size_type = std::vector<int>::size_type;  // reusing the vectors's size type


    TimeSeries& addValue (std::unique_ptr <Measurement> && v);

    std::unique_ptr<Measurement> amplitude () const                             // small member functions inline
    { return maxValuePointer->difference(*minValuePointer); }  // avoiding signed integer overflow

    bool operator<(const TimeSeries& t) const
    { return amplitude()->larger(*t.amplitude()); }

    friend std::ostream& operator<< (std::ostream& out, const TimeSeries& ts);

private:     // should be invoked when data is modified

    std::vector<std::unique_ptr<Measurement>> data;
    Measurement* maxValuePointer = nullptr;
    Measurement* minValuePointer = nullptr;
    // int              monthlyAverages[12];
};

// I choose to define short member functions inline
//----------------------------------------------------------
inline TimeSeries& TimeSeries::addValue (std::unique_ptr<Measurement> && v)
{
    if(maxValuePointer == nullptr && minValuePointer == nullptr){
        maxValuePointer = v.get();
        minValuePointer = v.get();
    }

    if (v->larger(*maxValuePointer)) maxValuePointer = v.get();
    if (maxValuePointer->larger(*v)) minValuePointer = v.get();

    data.push_back(std::move(v));


    return *this;
}

}

#endif // TIMESERIES_H_INCLUDED
